/*
 * Copyright (c) 2009 Matthew Hildebrand <matt.hildebrand@gmail.com>
 * Copyright (C) 2009, Progress Software Corporation and/or its
 * subsidiaries or affiliates.  All rights reserved.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
package org.fusesource.scalate


import _root_.scala.util.parsing.input.{OffsetPosition, Position}
import java.util.regex.Pattern
import java.net.URI
import java.io.File
import ssp.{ScriptletFragment, PageFragment}
import util.Logging
import collection.immutable.TreeMap

/**
 * Provides a common base class for CodeGenerator implementations.
 *
 * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
 */
abstract class AbstractCodeGenerator[T] extends CodeGenerator with Logging
{
  abstract class AbstractSourceBuilder[T] {
    var indent_level = 0
    var code = ""
    var generated_positions = Map[OffsetPosition, Int]()

    def <<(): this.type = <<("")

    def <<(line: String): this.type = {
      for (i <- 0 until indent_level) {
        code += "  ";
      }
      code += line + "\n";
      this
    }

    def << (pos:Position): this.type = {
      if( pos!=null ) {
        pos match {
          case p:OffsetPosition =>
            generated_positions = generated_positions + ( p -> current_position )
          case _=>
        }
      }
      this
    }

    def current_position = {
      code.length + (indent_level*2)
    }

    def positions() = {
      var rc = new TreeMap[OffsetPosition,OffsetPosition]()( new Ordering[OffsetPosition] {
        def compare(p1:OffsetPosition, p2:OffsetPosition):Int = {
          val rc = p1.line - p2.line
          if( rc==0 ) {
            p1.column - p2.column
          } else {
            rc
          }
        }
      })
      generated_positions.foreach {
        entry=>
          rc = rc + (OffsetPosition(code, entry._2)->entry._1)
      }
      rc
    }

    def indent[T](op: => T): T = {indent_level += 1; val rc = op; indent_level -= 1; rc}

    def generate(engine: TemplateEngine, packageName: String, className: String, bindings: List[Binding], statements: List[T]): Unit = {

      this << "/* NOTE this file is autogenerated by Scalate : see http://scalate.fusesource.org/ */"
      if (packageName != "") {
        this << "package " + packageName
      }

      this << ""

      val engineImports = engine.importStatements
      for (i <- engineImports) {
        this << i
      }
      if (!engineImports.isEmpty) {
        this << ""
      }

      this << "object " + className + "{"
      indent {
        // We prefix the function an variables with $_scalate_$ to avoid namespace pollution which could
        // conflict with definitions declared in the template
        this << "def $_scalate_$render($_scalate_$_context:_root_.org.fusesource.scalate.RenderContext): Unit = {"
        indent {

          // lets perform all the imports first

          val (imports, otherStatements) = {
            val firstNonImport = statements.findIndexOf(!isImportStatementOrCommentOrWhitespace(_))
            if (firstNonImport > 0) {
              statements.splitAt(firstNonImport)
            }
            else {
              (Nil, statements)
            }
          }

          generate(imports)
          generateBindings(bindings) {
            generate(otherStatements)
          }
        }
        this << "}"
      }
      this << "}"
      this <<;


      this <<;
      this << "class " + className + " extends _root_.org.fusesource.scalate.Template {"
      indent {
        this << "def render(context:_root_.org.fusesource.scalate.RenderContext): Unit = " + className + ".$_scalate_$render(context);"
      }
      this << "}"

    }

    def generate(statements: List[T]): Unit

    protected def isImportStatementOrCommentOrWhitespace(statement: T): Boolean

    def generateBindings(bindings: List[Binding])(body: => Unit): Unit = {
      bindings.foreach(arg => {
        generateBinding(arg)
        this << "{"
        indent_level += 1
      })

      body

      bindings.foreach(arg => {
        indent_level -= 1
        this << "}"
      })
    }

    def generateBinding(binding: Binding): Unit = {
      def generateImplicit = if (binding.isImplicit) "implicit " else ""
      
      this << generateImplicit + binding.kind + " " + binding.name + ":" + binding.className + " = ($_scalate_$_context.attributes.get(" + asString(binding.name) + ") match {"
      indent {
        //this << "case Some(value: "+binding.className+") => value"
        this << "case Some(value) => value.asInstanceOf[" + binding.className + "]"
        if (binding.defaultValue.isEmpty) {
          this << "case None => throw new _root_.org.fusesource.scalate.NoValueSetException(" + asString(binding.name) + ")"
        } else {
          this << "case None => " + binding.defaultValue.get
        }
      }
      this << "});"
      if (binding.importMembers) {
        this << "import " + binding.name + "._;";
      }
    }

    def asString(text: String): String = {
      val buffer = new StringBuffer
      buffer.append("\"")
      text.foreach(c => {
        if (c == '"')
          buffer.append("\\\"")
        else if (c == '\\')
          buffer.append("\\\\")
        else if (c == '\n')
          buffer.append("\\n")
        else if (c == '\r')
          buffer.append("\\r")
        else if (c == '\b')
          buffer.append("\\b")
        else if (c == '\t')
          buffer.append("\\t")
        else if ((c >= '#' && c <= '~') || c == ' ' || c == '!')
          buffer.append(c)
        else {
          buffer.append("\\u")
          buffer.append(format("%04x", c.asInstanceOf[Int]))
        }
      })
      buffer.append("\"")
      buffer.toString
    }
  }

  override def className(uri: String): String = {
    // Determine the package and class name to use for the generated class
    val (packageName, cn) = extractPackageAndClassNames(uri)

    // Build the complete class name (including the package name, if any)
    if (packageName == null || packageName.length == 0)
      cn
    else
      packageName + "." + cn
  }

  protected def extractPackageAndClassNames(uri: String): (String, String) = {
    
    def processClassName(cn: String) = cn.replace('.', '_').replace("-", "$dash")
    
    val normalizedURI: String = try {
      new URI(uri).normalize.toString
    } catch {
      // on windows we can't create a URI from files named things like C:/Foo/bar.ssp
      case e: Exception => val name = new File(uri).getCanonicalPath
      val sep = File.pathSeparator
      if (sep != "/") {
        // on windows lets replace the \ in a directory name with /
        val newName = name.replace('\\', '/')
        debug("convertedd windows path into: " + newName)
        newName
      }
      else {
        name
      }
    }
    val SPLIT_ON_LAST_SLASH_REGEX = Pattern.compile("^(.*)/([^/]*)$")
    val matcher = SPLIT_ON_LAST_SLASH_REGEX.matcher(normalizedURI.toString)
    if (matcher.matches == false) {
      // lets assume we have no package then
      val cn = "$_scalate_$" + processClassName(normalizedURI)
      ("", cn)
    }
    else {
      val unsafePackageNameWithWebInf = matcher.group(1).replaceAll("[^A-Za-z0-9_/]", "_").replaceAll("/", ".").replaceFirst("^\\.", "")

      // lets remove WEB-INF from the first name, since we should consider stuff in WEB-INF/org/foo as being in package org.foo
      val unsafePackageName = unsafePackageNameWithWebInf.stripPrefix("WEB_INF.")

      var packages = unsafePackageName.split("\\.")

      // lets find the tail of matching package names to use
      val lastIndex = packages.findLastIndexOf(invalidPackageName(_))
      if (lastIndex > 0) {
        packages = packages.drop(lastIndex + 1)
      }

      //val packageName = packages.map(safePackageName(_)).mkString(".")
      val packageName = packages.mkString(".")

      val cn = "$_scalate_$" + processClassName(matcher.group(2))
      (packageName, cn)
    }
  }

  /**
   * Filter out any dodgy package names
   */
  private def invalidPackageName(name: String): Boolean = name.isEmpty || reservedWords.contains(name) || name(0).isDigit || name(0) == '_'

  protected val reservedWords = Set[String]("package", "class", "trait", "if", "else", "while", "def", "extends", "val", "var")
}
