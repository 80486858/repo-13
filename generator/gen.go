package generator

import (
	"fmt"
	"runtime/debug"
	"strconv"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/runtime/protoimpl"
)

/*
	╭━━━┳╮╱╭┳╮╱╱╭━━━┳━━━┳━━━╮
	┃╭━╮┃┃╱┃┃┃╱╱┃╭━╮┃╭━╮┃╭━╮┃
	┃╰━╯┃┃╱┃┃┃╱╱┃╰━━┫┃╱┃┃╰━╯┃
	┃╭━━┫┃╱┃┃┃╱╭╋━━╮┃╰━╯┃╭╮╭╯
	┃┃╱╱┃╰━╯┃╰━╯┃╰━╯┃╭━╮┃┃┃╰╮
	╰╯╱╱╰━━━┻━━━┻━━━┻╯╱╰┻╯╰━╯

	- many bytes, such speed. -
*/

type structTags [][2]string

// Standard library dependencies.
const (
	base64Package  = protogen.GoImportPath("encoding/base64")
	mathPackage    = protogen.GoImportPath("math")
	reflectPackage = protogen.GoImportPath("reflect")
	sortPackage    = protogen.GoImportPath("sort")
	stringsPackage = protogen.GoImportPath("strings")
	syncPackage    = protogen.GoImportPath("sync")
	timePackage    = protogen.GoImportPath("time")
	utf8Package    = protogen.GoImportPath("unicode/utf8")
)

// Protobuf library dependencies.
//
// These are declared as an interface type so that they can be more easily
// patched to support unique build environments that impose restrictions
// on the dependencies of generated source code.
var (
	FILENAME             string
	protoPackage         goImportPath = protogen.GoImportPath("google.golang.org/protobuf/proto")
	protoifacePackage    goImportPath = protogen.GoImportPath("google.golang.org/protobuf/runtime/protoiface")
	protoimplPackage     goImportPath = protogen.GoImportPath("google.golang.org/protobuf/runtime/protoimpl")
	protojsonPackage     goImportPath = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
	protoreflectPackage  goImportPath = protogen.GoImportPath("google.golang.org/protobuf/reflect/protoreflect")
	protoregistryPackage goImportPath = protogen.GoImportPath("google.golang.org/protobuf/reflect/protoregistry")
)

type goImportPath interface {
	String() string
	Ident(string) protogen.GoIdent
}

func GenerateProtocGenGo(g *GeneratedFile, file *protogen.File) *GeneratedFile {
	FILENAME = file.GeneratedFilenamePrefix
	genPackage(g, file.GoPackageName, file)
	genVersionMarkers(g)
	for i,msg := range file.Messages {
		genMsgStruct(g, msg, i)
		g.P()
	}
	genFileProtoTypes(g, file)
	return g
}

func genFileProtoTypes(g *GeneratedFile, file *protogen.File) {
	g.P("var File_", file.GeneratedFilenamePrefix,"_proto ", protoreflectPackage.Ident("FileDescriptor"))
	g.P("var file_", file.GeneratedFilenamePrefix,"_proto_msgTypes = make([]", protoimplPackage.Ident("MessageInfo"), ", ", len(file.Messages), ")")
	g.P("var file_", file.GeneratedFilenamePrefix, "_proto_goTypes = []interface{}{")
	for i, msg := range file.Messages {
		g.P("(*", msg.GoIdent.GoName, ")(nil), // ", i, ": cosmos.proto.", msg.GoIdent.GoName)
	}
	g.P("}")
}

func genPackage(g *GeneratedFile, packageName protogen.GoPackageName, file *protogen.File) {
	g.P("// Code generated by Pulsar by Cosmos. DO NOT EDIT.")
	if bi, ok := debug.ReadBuildInfo(); ok {
		g.P("// Pulsar version: ", bi.Main.Version)
	}
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", packageName)
	g.P()
}

func genVersionMarkers(g *GeneratedFile) {
	g.P("const (")
	g.P("// Verify that this generated code is sufficiently up-to-date.")
	g.P("_ = ", protoimplPackage.Ident("EnforceVersion"), "(", protoimpl.GenVersion, " - ", protoimplPackage.Ident("MinVersion"), ")")
	g.P("// Verify that runtime/protoimpl is sufficiently up-to-date.")
	g.P("_ = ", protoimplPackage.Ident("EnforceVersion"), "(", protoimplPackage.Ident("MaxVersion"), " - ", protoimpl.GenVersion, ")")
	g.P(")")
	g.P()
}

func genMsgStruct(g *GeneratedFile, msg *protogen.Message, index int) {
	g.P(msg.Comments.Leading,"type ", msg.GoIdent.GoName, " struct {")
	genStdFields(g, msg)
	g.P()
	for _,field := range msg.Fields {
		genField(g, field)
	}
	g.P("}")
	//genReset(g, msg) // not sure wtf this is for
	genString(g, msg)
	g.P()
	//genProtoMessage(g, msg)
	genProtoReflect(g, msg, index)
	g.P()
	genGetters(g, msg)
	g.P()
}

func genStdFields(g *GeneratedFile, msg *protogen.Message) {
	g.P("state ", protoimplPackage.Ident("MessageState"))
	g.P("sizeCache ", protoimplPackage.Ident("SizeCache"))
	g.P("unknownFields ", protoimplPackage.Ident("UnknownFields"))
}

func genField(g *GeneratedFile, field *protogen.Field) {
	if oneof := field.Oneof; oneof != nil && !oneof.Desc.IsSynthetic() {
		// It would be a bit simpler to iterate over the oneofs below,
		// but generating the field here keeps the contents of the Go
		// struct in the same order as the contents of the source
		// .proto file.
		if oneof.Fields[0] != field {
			return // only generate for first appearance
		}

		//tags := structTags{
		//	{"protobuf_oneof", string(oneof.Desc.Name())},
		//}

		g.Annotate(field.GoIdent.GoName+"."+oneof.GoName, oneof.Location)
		leadingComments := oneof.Comments.Leading
		if leadingComments != "" {
			leadingComments += "\n"
		}
		ss := []string{fmt.Sprintf(" Types that are assignable to %s:\n", oneof.GoName)}
		for _, field := range oneof.Fields {
			ss = append(ss, "\t*"+field.GoIdent.GoName+"\n")
		}
		leadingComments += protogen.Comments(strings.Join(ss, ""))
		g.P(oneof.GoName, " ", oneOfInterfaceName(oneof))
		return
	}
	goType, isPointer := getType(g, field)
	if isPointer {
		goType = "*" + goType
	}
	//tags := structTags{
	//	{"protobuf", fieldProtobufTagValue(field)},
	//	{"json", fieldJSONTagValue(field)},
	//	{"yaml", fieldYAMLTagValue(field)},
	//}
	// we'll use the tags below when they're implemented
	g.P(field.Comments.Leading, field.GoName, " ", goType)
}

func getType(g *GeneratedFile, field *protogen.Field) (goType string, pointer bool) {
	if field.Desc.IsWeak() {
		return "struct{}", false
	}

	pointer = field.Desc.HasPresence()
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		goType = "bool"
	case protoreflect.EnumKind:
		goType = g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		goType = "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		goType = "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		goType = "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		goType = "uint64"
	case protoreflect.FloatKind:
		goType = "float32"
	case protoreflect.DoubleKind:
		goType = "float64"
	case protoreflect.StringKind:
		goType = "string"
	case protoreflect.BytesKind:
		goType = "[]byte"
		pointer = false // rely on nullability of slices for presence
	case protoreflect.MessageKind, protoreflect.GroupKind:
		goType = "*" + g.QualifiedGoIdent(field.Message.GoIdent)
		pointer = false // pointer captured as part of the type
	}
	switch {
	case field.Desc.IsList():
		return "[]" + goType, false
	// we dont use maps
	//case field.Desc.IsMap():
	//	keyType, _ := fieldGoType(g, f, field.Message.Fields[0])
	//	valType, _ := fieldGoType(g, f, field.Message.Fields[1])
	//	return fmt.Sprintf("map[%v]%v", keyType, valType), false
	}
	return goType, pointer
}

func fieldProtobufTagValue(field *protogen.Field) string {
	return "not impl"
}

func fieldJSONTagValue(field *protogen.Field) string {
	return "not impl"
}

func fieldYAMLTagValue(field *protogen.Field) string {
	return "not impl"
}

func genString(g *GeneratedFile, msg *protogen.Message) {
	g.P("func (x *", msg.GoIdent.GoName, ") String() string {")
	g.P("return ", protoimplPackage.Ident("X.MessageStringOf(x)"))
	g.P("}")
}

// oneOfInterfaceName returns the name of the interface type implemented by
// the oneof field value types.
func oneOfInterfaceName(oneof *protogen.Oneof) string {
	return "is" + oneof.GoIdent.GoName
}

func genGetters(g *GeneratedFile, msg *protogen.Message) {
	for _, field := range msg.Fields {
		goType, pointer := getType(g, field)
		// Getter for parent oneof.
		if oneof := field.Oneof; oneof != nil && oneof.Fields[0] == field && !oneof.Desc.IsSynthetic() {
			g.P("type ", oneOfInterfaceName(oneof), " interface {")
			g.P(oneOfInterfaceName(oneof), "()")
			g.P("}")
			g.P()
			g.Annotate(msg.GoIdent.GoName+".Get"+oneof.GoName, oneof.Location)
			g.P("func (m *", msg.GoIdent.GoName, ") Get", oneof.GoName, "() ", oneOfInterfaceName(oneof), " {")
			g.P("if m != nil {")
			g.P("return m.", oneof.GoName)
			g.P("}")
			g.P("return nil")
			g.P("}")
			g.P()

			for _,v := range oneof.Fields {
				g.P("type ", v.GoIdent, " struct {")
				g.P(v.GoName, " ", goType)
				g.P("}")
				g.P()
			}

			for _,one := range oneof.Fields {
				g.P("func (*", one.GoIdent, ") ", oneOfInterfaceName(oneof), "() {}")
				g.P()
			}
		}

		// Getter for message field.
		g.Annotate(msg.GoIdent.GoName+".Get"+field.GoName, field.Location)
		defaultValue := "var y " + goType
		switch {
		case field.Desc.IsWeak():
			g.P(field.Comments.Leading, "func (x *", msg.GoIdent, ") Get", field.GoName, "() ", protoPackage.Ident("Message"), "{")
			g.P("var w ", protoimplPackage.Ident("WeakFields"))
			g.P("if x != nil {")
			g.P("w = x.weakFields")
			g.P("}")
			g.P("return ", protoimplPackage.Ident("X"), ".GetWeak(w, ", field.Desc.Number(), ", ", strconv.Quote(string(field.Message.Desc.FullName())), ")")
			g.P("}")
		case field.Oneof != nil && !field.Oneof.Desc.IsSynthetic():
			g.P(field.Comments.Leading, "func (x *", msg.GoIdent, ") Get", field.GoName, "() ", goType, " {")
			g.P("if x, ok := x.Get", field.Oneof.GoName, "().(*", field.GoIdent, "); ok {")
			g.P("return x.", field.GoName)
			g.P("}")
			g.P(defaultValue)
			g.P("return y")
			g.P("}")
		default:
			g.P(field.Comments.Leading, "func (x *", msg.GoIdent, ") Get", field.GoName, "() ", goType, " {")
			if !field.Desc.HasPresence() || defaultValue == "nil" {
				g.P("if x != nil {")
			} else {
				g.P("if x != nil && x.", field.GoName, " != nil {")
			}
			star := ""
			if pointer {
				star = "*"
			}
			g.P("return ", star, " x.", field.GoName)
			g.P("}")
			g.P(defaultValue)
			g.P("return y")
			g.P("}")
		}
		g.P()
	}
}

func genProtoReflect(g *GeneratedFile, msg *protogen.Message, index int) {
	genFunctionSignature(g, true, "x", msg.GoIdent.GoName, "ProtoReflect", protoreflectPackage.Ident("Message"), []args{})
	g.P("mi := &file_", FILENAME, "_proto_msgTypes[", index, "]")
	g.P("if ", protoimplPackage.Ident("UnsafeEnabled"), " && x != nil {")
	g.P("ms := ", protoimplPackage.Ident("X.MessageStateOf"), "(", protoimplPackage.Ident("Pointer"), "(x))")
	g.P("if ms.LoadMessageInfo() == nil {")
	g.P("ms.StoreMessageInfo(mi)")
	g.P("}")
	g.P("return ms")
	g.P("}")
	g.P("return mi.MessageOf(x)")
	g.P("}")
}

type args struct {
	name string
	typ3 string
}

func genFunctionSignature(g *GeneratedFile, isPointer bool, receiverVar, receiverStruct, funcName string, returns protogen.GoIdent, argz []args) {
	if isPointer {
		receiverStruct = "*" + receiverStruct
	}
	var arguments string
	if len(argz) == 1 {
		arguments = fmt.Sprintf("%v %v", argz[0].name, argz[0].typ3)
	} else if len(argz) > 1 {
		for _,v := range argz {
			arguments += fmt.Sprintf("%v %v, ", v.name, v.typ3)
		}
		// get rid of trailing comma/space
		arguments = arguments[:len(arguments)-2]
	}

	g.P("func (", receiverVar, " ", receiverStruct, ") ",funcName, "(", arguments, ")", returns, " {")
}
