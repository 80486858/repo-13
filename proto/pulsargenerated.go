//// Code generated by Pulsar ü™ê. DO NOT EDIT.
//// Pulsar version: (devel)
//// source: foo.proto
//

// WIP FOR protoreflect.Message impl

package examples
//
//import (
//	"errors"
//	fmt "fmt"
//	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
//	"google.golang.org/protobuf/runtime/protoiface"
//	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
//	io "io"
//	bits "math/bits"
//	"reflect"
//	"sync"
//)
//
//const (
//	// Verify that this generated code is sufficiently up-to-date.
//	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
//	// Verify that runtime/protoimpl is sufficiently up-to-date.
//	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
//)
//
//var (
//	_ protoreflect.Message = Bar{}
//)
//
//type Bar struct {
//	state         protoimpl.MessageState
//	sizeCache     protoimpl.SizeCache
//	unknownFields protoimpl.UnknownFields
//
//	Baz string `protobuf:"bytes,1,opt,name=baz,proto3" json:"baz,omitempty" yaml:"baz"`
//}
//
//func (x Bar) GetMethods() *protoiface.Methods {
//	m := protoiface.Methods{
//		NoUnkeyedLiterals: struct{}{},
//		Flags:             0,
//		Size:              func(input protoiface.SizeInput) protoiface.SizeOutput {
//			n := x.Size()
//			return protoiface.SizeOutput{
//				NoUnkeyedLiterals: struct{}{},
//				Size:              n,
//			}
//		},
//		Marshal:           func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
//			v, ok := input.Message.(Bar)
//			if !ok {
//				return protoiface.MarshalOutput{}, errors.New("Bar does not implement proto.Message")
//			}
//
//			bz, err := v.Marshal()
//			if err != nil {
//				return protoiface.MarshalOutput{}, err
//			}
//			return protoiface.MarshalOutput{
//				NoUnkeyedLiterals: struct{}{},
//				Buf:               bz,
//			}, nil
//		},
//		Unmarshal:         func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error){
//			v, ok := input.Message.(*Bar)
//			if !ok {
//				return protoiface.UnmarshalOutput{}, errors.New("Bar does not implement proto.Message")
//			}
//
//			err := v.Unmarshal(input.Buf)
//			if err != nil {
//				return protoiface.UnmarshalOutput{},err
//			}
//
//			return protoiface.UnmarshalOutput{
//				NoUnkeyedLiterals: struct{}{},
//				Flags:             0,
//			}, nil
//		},
//		Merge:             nil,
//		CheckInitialized:  nil,
//	}
//	return &m
//}
//
//// ===---=== Methods for Bar that implement the protoreflect.Message interface ===---===
//
//// Descriptor returns message descriptor, which contains only the protobuf
//// type information for the message.
//func (x Bar) Descriptor() protoreflect.MessageDescriptor {
//	return nil
//}
//
//// Type returns the message type, which encapsulates both Go and protobuf
//// type information. If the Go type information is not needed,
//// it is recommended that the message descriptor be used instead.
//func (x Bar) Type() protoreflect.MessageType {
//	return nil
//}
//
//// New returns a newly allocated and mutable empty message.
//func (x Bar) New() protoreflect.Message {
//	return &Bar{
//		state:         protoimpl.MessageState{},
//		sizeCache:     0,
//		unknownFields: nil,
//		Baz:           "",
//	}
//}
//
//// Interface unwraps the message reflection interface and
//// returns the underlying ProtoMessage interface.
//func (x Bar) Interface() protoreflect.ProtoMessage {
//	return &x // ???
//}
//
//// Range iterates over every populated field in an undefined order,
//// calling f for each field descriptor and value encountered.
//// Range returns immediately if f returns false.
//// While iterating, mutating operations may only be performed
//// on the current field descriptor.
//func (x Bar) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
//	gtype := reflect.TypeOf(x)
//	numFields := gtype.NumField()
//	// rg := reflect.ValueOf(&x)
//	for i := 0; i < numFields; i++ {
//		// TODO: no idea what to do here tbh
//	}
//}
//
//// Has reports whether a field is populated.
////
//// Some fields have the property of nullability where it is possible to
//// distinguish between the default value of a field and whether the field
//// was explicitly populated with the default value. Singular message fields,
//// member fields of a oneof, and proto2 scalar fields are nullable. Such
//// fields are populated only if explicitly set.
////
//// In other cases (aside from the nullable cases above),
//// a proto3 scalar field is populated if it contains a non-zero value, and
//// a repeated field is populated if it is non-empty.
//func (x Bar) Has(descriptor protoreflect.FieldDescriptor) bool {
//	// TODO: we might be able to do descriptor.Parent() and check if it == x here. but not sure how to use descriptors yet.
//	has := false
//	x.Range(func(f protoreflect.FieldDescriptor, v protoreflect.Value) bool{
//		if f == descriptor {
//			has = true
//			return false
//		}
//		return true
//	})
//	return has
//}
//
//// Clear clears the field such that a subsequent Has call reports false.
////
//// Clearing an extension field clears both the extension type and value
//// associated with the given field number.
////
//// Clear is a mutating operation and unsafe for concurrent use.
//func (x Bar) Clear(descriptor protoreflect.FieldDescriptor) {
//	panic("implement me")
//	// TODO: no idea how to do this
//}
//
//// Get retrieves the value for a field.
////
//// For unpopulated scalars, it returns the default value, where
//// the default value of a bytes scalar is guaranteed to be a copy.
//// For unpopulated composite types, it returns an empty, read-only view
//// of the value; to obtain a mutable reference, use Mutable.
//func (x Bar) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
//	panic("implement me")
//}
//
//// Set stores the value for a field.
////
//// For a field belonging to a oneof, it implicitly clears any other field
//// that may be currently set within the same oneof.
//// For extension fields, it implicitly stores the provided ExtensionType.
//// When setting a composite type, it is unspecified whether the stored value
//// aliases the source's memory in any way. If the composite value is an
//// empty, read-only value, then it panics.
////
//// Set is a mutating operation and unsafe for concurrent use.
//func (x Bar) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
//	panic("implement me")
//}
//
//// Mutable returns a mutable reference to a composite type.
////
//// If the field is unpopulated, it may allocate a composite value.
//// For a field belonging to a oneof, it implicitly clears any other field
//// that may be currently set within the same oneof.
//// For extension fields, it implicitly stores the provided ExtensionType
//// if not already stored.
//// It panics if the field does not contain a composite type.
////
//// Mutable is a mutating operation and unsafe for concurrent use.
//func (x Bar) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
//	panic("implement me")
//}
//
//// NewField returns a new value that is assignable to the field
//// for the given descriptor. For scalars, this returns the default value.
//// For lists, maps, and messages, this returns a new, empty, mutable value.
//func (x Bar) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
//	panic("implement me")
//}
//
//// WhichOneof reports which field within the oneof is populated,
//// returning nil if none are populated.
//// It panics if the oneof descriptor does not belong to this message.
//func (x Bar) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
//	panic("implement me")
//}
//
//// GetUnknown retrieves the entire list of unknown fields.
//// The caller may only mutate the contents of the RawFields
//// if the mutated bytes are stored back into the message with SetUnknown.
//func (x Bar) GetUnknown() protoreflect.RawFields {
//	panic("implement me")
//}
//
//// SetUnknown stores an entire list of unknown fields.
//// The raw fields must be syntactically valid according to the wire format.
//// An implementation may panic if this is not the case.
//// Once stored, the caller must not mutate the content of the RawFields.
//// An empty RawFields may be passed to clear the fields.
////
//// SetUnknown is a mutating operation and unsafe for concurrent use.
//func (x Bar) SetUnknown(fields protoreflect.RawFields) {
//	panic("implement me")
//}
//
//// IsValid reports whether the message is valid.
////
//// An invalid message is an empty, read-only value.
////
//// An invalid message often corresponds to a nil pointer of the concrete
//// message type, but the details are implementation dependent.
//// Validity is not part of the protobuf data model, and may not
//// be preserved in marshaling or other operations.
//func (x Bar) IsValid() bool {
//	panic("implement me")
//}
//
//// ProtoMethods returns optional fast-path implementions of various operations.
//// This method may return nil.
////
//// The returned methods type is identical to
//// "google.golang.org/protobuf/runtime/protoiface".Methods.
//// Consult the protoiface package documentation for details.
//func (x Bar) ProtoMethods() *protoiface.Methods {
//	return x.GetMethods()
//}
//
//
//func (x *Bar) Reset() {
//	*x = Bar{}
//	if protoimpl.UnsafeEnabled {
//		mi := &file_foo_proto_msgTypes[0]
//		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
//		ms.StoreMessageInfo(mi)
//	}
//}
//
//func (x *Bar) String() string {
//	return protoimpl.X.MessageStringOf(x)
//}
//
//func (x *Bar) ProtoMessage() {}
//
//func (x *Bar) ProtoReflect() protoreflect.Message {
//	mi := &file_foo_proto_msgTypes[0]
//	if protoimpl.UnsafeEnabled && x != nil {
//		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
//		if ms.LoadMessageInfo() == nil {
//			ms.StoreMessageInfo(mi)
//		}
//		return ms
//	}
//	return mi.MessageOf(x)
//}
//
//func (x *Bar) GetBaz() string {
//	if x != nil {
//		return x.Baz
//	}
//	var y string
//	return y
//}
//
//func (m *Bar) Marshal() (dAtA []byte, err error) {
//	if m == nil {
//		return nil, nil
//	}
//	size := m.Size()
//	dAtA = make([]byte, size)
//	n, err := m.MarshalToSizedBuffer(dAtA[:size])
//	if err != nil {
//		return nil, err
//	}
//	return dAtA[:n], nil
//}
//
//func (m *Bar) MarshalTo(dAtA []byte) (int, error) {
//	size := m.Size()
//	return m.MarshalToSizedBuffer(dAtA[:size])
//}
//
//func (m *Bar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
//	if m == nil {
//		return 0, nil
//	}
//	i := len(dAtA)
//	_ = i
//	var l int
//	_ = l
//	if m.unknownFields != nil {
//		i -= len(m.unknownFields)
//		copy(dAtA[i:], m.unknownFields)
//	}
//	if len(m.Baz) > 0 {
//		i -= len(m.Baz)
//		copy(dAtA[i:], m.Baz)
//		i = encodeVarint(dAtA, i, uint64(len(m.Baz)))
//		i--
//		dAtA[i] = 0xa
//	}
//	return len(dAtA) - i, nil
//}
//
//func encodeVarint(dAtA []byte, offset int, v uint64) int {
//	offset -= sov(v)
//	base := offset
//	for v >= 1<<7 {
//		dAtA[offset] = uint8(v&0x7f | 0x80)
//		v >>= 7
//		offset++
//	}
//	dAtA[offset] = uint8(v)
//	return base
//}
//func (m *Bar) Size() (n int) {
//	if m == nil {
//		return 0
//	}
//	var l int
//	_ = l
//	l = len(m.Baz)
//	if l > 0 {
//		n += 1 + l + sov(uint64(l))
//	}
//	if m.unknownFields != nil {
//		n += len(m.unknownFields)
//	}
//	return n
//}
//
//func sov(x uint64) (n int) {
//	return (bits.Len64(x|1) + 6) / 7
//}
//func soz(x uint64) (n int) {
//	return sov(uint64((x << 1) ^ uint64((int64(x) >> 63))))
//}
//func (m *Bar) Unmarshal(dAtA []byte) error {
//	l := len(dAtA)
//	iNdEx := 0
//	for iNdEx < l {
//		preIndex := iNdEx
//		var wire uint64
//		for shift := uint(0); ; shift += 7 {
//			if shift >= 64 {
//				return ErrIntOverflow
//			}
//			if iNdEx >= l {
//				return io.ErrUnexpectedEOF
//			}
//			b := dAtA[iNdEx]
//			iNdEx++
//			wire |= uint64(b&0x7F) << shift
//			if b < 0x80 {
//				break
//			}
//		}
//		fieldNum := int32(wire >> 3)
//		wireType := int(wire & 0x7)
//		if wireType == 4 {
//			return fmt.Errorf("proto: Bar: wiretype end group for non-group")
//		}
//		if fieldNum <= 0 {
//			return fmt.Errorf("proto: Bar: illegal tag %d (wire type %d)", fieldNum, wire)
//		}
//		switch fieldNum {
//		case 1:
//			if wireType != 2 {
//				return fmt.Errorf("proto: wrong wireType = %d for field Baz", wireType)
//			}
//			var stringLen uint64
//			for shift := uint(0); ; shift += 7 {
//				if shift >= 64 {
//					return ErrIntOverflow
//				}
//				if iNdEx >= l {
//					return io.ErrUnexpectedEOF
//				}
//				b := dAtA[iNdEx]
//				iNdEx++
//				stringLen |= uint64(b&0x7F) << shift
//				if b < 0x80 {
//					break
//				}
//			}
//			intStringLen := int(stringLen)
//			if intStringLen < 0 {
//				return ErrInvalidLength
//			}
//			postIndex := iNdEx + intStringLen
//			if postIndex < 0 {
//				return ErrInvalidLength
//			}
//			if postIndex > l {
//				return io.ErrUnexpectedEOF
//			}
//			m.Baz = string(dAtA[iNdEx:postIndex])
//			iNdEx = postIndex
//		default:
//			iNdEx = preIndex
//			skippy, err := skip(dAtA[iNdEx:])
//			if err != nil {
//				return err
//			}
//			if (skippy < 0) || (iNdEx+skippy) < 0 {
//				return ErrInvalidLength
//			}
//			if (iNdEx + skippy) > l {
//				return io.ErrUnexpectedEOF
//			}
//			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
//			iNdEx += skippy
//		}
//	}
//
//	if iNdEx > l {
//		return io.ErrUnexpectedEOF
//	}
//	return nil
//}
//func skip(dAtA []byte) (n int, err error) {
//	l := len(dAtA)
//	iNdEx := 0
//	depth := 0
//	for iNdEx < l {
//		var wire uint64
//		for shift := uint(0); ; shift += 7 {
//			if shift >= 64 {
//				return 0, ErrIntOverflow
//			}
//			if iNdEx >= l {
//				return 0, io.ErrUnexpectedEOF
//			}
//			b := dAtA[iNdEx]
//			iNdEx++
//			wire |= (uint64(b) & 0x7F) << shift
//			if b < 0x80 {
//				break
//			}
//		}
//		wireType := int(wire & 0x7)
//		switch wireType {
//		case 0:
//			for shift := uint(0); ; shift += 7 {
//				if shift >= 64 {
//					return 0, ErrIntOverflow
//				}
//				if iNdEx >= l {
//					return 0, io.ErrUnexpectedEOF
//				}
//				iNdEx++
//				if dAtA[iNdEx-1] < 0x80 {
//					break
//				}
//			}
//		case 1:
//			iNdEx += 8
//		case 2:
//			var length int
//			for shift := uint(0); ; shift += 7 {
//				if shift >= 64 {
//					return 0, ErrIntOverflow
//				}
//				if iNdEx >= l {
//					return 0, io.ErrUnexpectedEOF
//				}
//				b := dAtA[iNdEx]
//				iNdEx++
//				length |= (int(b) & 0x7F) << shift
//				if b < 0x80 {
//					break
//				}
//			}
//			if length < 0 {
//				return 0, ErrInvalidLength
//			}
//			iNdEx += length
//		case 3:
//			depth++
//		case 4:
//			if depth == 0 {
//				return 0, ErrUnexpectedEndOfGroup
//			}
//			depth--
//		case 5:
//			iNdEx += 4
//		default:
//			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
//		}
//		if iNdEx < 0 {
//			return 0, ErrInvalidLength
//		}
//		if depth == 0 {
//			return iNdEx, nil
//		}
//	}
//	return 0, io.ErrUnexpectedEOF
//}
//
//var (
//	ErrInvalidLength        = fmt.Errorf("proto: negative length found during unmarshaling")
//	ErrIntOverflow          = fmt.Errorf("proto: integer overflow")
//	ErrUnexpectedEndOfGroup = fmt.Errorf("proto: unexpected end of group")
//)
//
//var File_foo_proto protoreflect.FileDescriptor
//
//var file_foo_proto_rawDesc = []byte{
//	0x0a, 0x09, 0x66, 0x6f, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x63, 0x6f, 0x73,
//	0x6d, 0x6f, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x17, 0x0a, 0x03, 0x42, 0x61, 0x72,
//	0x12, 0x10, 0x0a, 0x03, 0x62, 0x61, 0x7a, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x62,
//	0x61, 0x7a, 0x42, 0x29, 0x5a, 0x27, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
//	0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2d, 0x70,
//	0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73, 0x62, 0x06, 0x70,
//	0x72, 0x6f, 0x74, 0x6f, 0x33,
//}
//
//var (
//	file_foo_proto_rawDescOnce sync.Once
//	file_foo_proto_rawDescData = file_foo_proto_rawDesc
//)
//
//func file_foo_proto_rawDescGZIP() []byte {
//	file_foo_proto_rawDescOnce.Do(func() {
//		file_foo_proto_rawDescData = protoimpl.X.CompressGZIP(file_foo_proto_rawDescData)
//	})
//	return file_foo_proto_rawDescData
//}
//
//var file_foo_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
//var file_foo_proto_goTypes = []interface{}{
//	(*Bar)(nil), // 0: cosmos.proto.Bar
//}
//var file_foo_proto_depIdxs = []int32{
//	0, // [0:0] is the sub-list for method output_type
//	0, // [0:0] is the sub-list for method input_type
//	0, // [0:0] is the sub-list for extension type_name
//	0, // [0:0] is the sub-list for extension extendee
//	0, // [0:0] is the sub-list for field type_name
//}
//
//func init() { file_foo_proto_init() }
//func file_foo_proto_init() {
//	if File_foo_proto != nil {
//		return
//	}
//	if !protoimpl.UnsafeEnabled {
//		file_foo_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
//			switch v := v.(*Bar); i {
//			case 0:
//				return &v.state
//			case 1:
//				return &v.sizeCache
//			case 2:
//				return &v.unknownFields
//			default:
//				return nil
//			}
//		}
//	}
//	type x struct{}
//	out := protoimpl.TypeBuilder{
//		File: protoimpl.DescBuilder{
//			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
//			RawDescriptor: file_foo_proto_rawDesc,
//			NumEnums:      0,
//			NumMessages:   1,
//			NumExtensions: 0,
//			NumServices:   0,
//		},
//		GoTypes:           file_foo_proto_goTypes,
//		DependencyIndexes: file_foo_proto_depIdxs,
//		MessageInfos:      file_foo_proto_msgTypes,
//	}.Build()
//	File_foo_proto = out.File
//	file_foo_proto_rawDesc = nil
//	file_foo_proto_goTypes = nil
//	file_foo_proto_depIdxs = nil
//}
