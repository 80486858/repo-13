/*
 * Copyright (c) 2009 Matthew Hildebrand <matt.hildebrand@gmail.com>
 * Copyright (C) 2009, Progress Software Corporation and/or its
 * subsidiaries or affiliates.  All rights reserved.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
package org.fusesource.scalate.haml

import org.fusesoruce.scalate.haml._
import java.util.regex.Pattern
import java.net.URI
import org.fusesource.scalate._

/**
 * Generates a scala class given a HAML document
 *
 * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
 */
class HamlCodeGenerator extends CodeGenerator
{

  private class SourceBuilder {

    var indent_level=0
    var code = ""

    def <<(): this.type = <<("")
    def <<(line:String): this.type = {
      for( i <-0 until indent_level ) {
        code += "  ";
      }
      code += line+"\n";
      this
    }

    def indent[T](op: => T):T = { indent_level += 1; val rc=op; indent_level-=1; rc }

    def generate(packageName:String, className:String, statements:List[Statement], params:List[TemplateArg]):Unit = {

      this << "/* NOTE this file is autogenerated by Scalate : see http://scalate.fusesource.org/ */"
      if (packageName != "") {
        this << "package "+packageName
      }

      this <<;
      this << "object " + className + "{"
      indent {
        // We prefix the function an variables with $_scalate_$ to avoid namespace pollution which could
        // conflict with definitions declared in the template
        this << "def $_scalate_$render($_scalate_$_out:org.fusesource.scalate.RenderCollector, $_scalate_$_bindings:Map[String, Any]): Unit = {"
        indent {
          params.foreach(arg=>{
            generateBinding(arg)
            this << "{"
            indent_level+=1
          })

          generate(statements)

          params.foreach(arg=>{
            indent_level-=1
            this << "}"
          })
        }
        this <<"}"
      }
      this <<"}"
      this <<;


      this <<;
      this << "class " + className + " extends org.fusesource.scalate.Template {"
      indent {
        this << "def renderTemplate(out:org.fusesource.scalate.RenderCollector,bindings:Map[String, Any]): Unit = "+className+".$_scalate_$render(out, bindings);"
      }
      this <<"}"

    }

    def generateBinding(arg:TemplateArg):Unit = {
      this << "val "+arg.name+":"+arg.className+" = $_scalate_$_bindings.getOrElse(\"" + arg.name + "\", " + arg.defaultValue.getOrElse("null")+ ").asInstanceOf["+arg.className+"];"
      if( arg.importMembers ) {
        this << "import "+arg.name+"._";
      }
    }

    def generate(statements:List[Statement]):Unit = {
      statements.foreach(statement=>{
        generate(statement)
      })
    }

    def generate(statement:Statement):Unit = {
      statement match {
        case s:HamlComment=> {
          this << "// "+renderText(s.text.getOrElse(""))
        }
        case s:HtmlComment=> {
          this << "$_scalate_$_out << ( \"<!--"+renderText(s.text.getOrElse(""))+"-->\");"
        }
        case s:LiteralText=> {
          this << "$_scalate_$_out << ( \""+renderText(s.text)+"\" );"
        }
        case s:EvaluatedText=> {
          this << "$_scalate_$_out << ( "+s.code+");"
        }
        case s:Element=> {
          generate(s)
        }
        case s:Executed=> {
          generate(s)
        }
        case s:Filter=> {
          throw new UnsupportedOperationException("filters not yet implemented.");
        }
      }
    }

    def generate(statement:Executed):Unit = {
      statement match {
        case Executed(Some(code), List()) => {
          this << code
        }
        case Executed(Some(code), list) => {
          this << code + " {"
          indent {
            generate(list)
          }
          this << "}"
        }
        case Executed(None,List())=> {}
      }
    }

    def generate(statement:Element):Unit = {
      val tag = statement.tag.getOrElse("div");
      this << "$_scalate_$_out << ( \"<"+renderText(tag+attributes(statement.attributes))+">"+"\" );"
      statement match {
        case Element(_,_,None, List(), _, _) => {}
        case Element(_,_,Some(text), List(), _, _) => {
          generate(text)
        }
        case Element(_,_,None, list, _, _) => {
          generate(list)
        }
        case _ => throw new IllegalArgumentException("Syntax error on line "+statement.pos.line+": Illegal nesting: content can't be both given on the same line as html element and nested within it.");
      }
      this << "$_scalate_$_out << ( \"</"+renderText(tag)+">"+"\" );"
    }

    def attributes(entries: List[(Any,Any)]) = {
      val (entries_class, entries_rest) = entries.partition{x=>{ x._1 match { case "class" => true; case _=> false} } }
      var map = Map( entries_rest: _* )

      if( !entries_class.isEmpty ) {
        val value = entries_class.map(x=>x._2).mkString(" ")
        map += "class"->value
      }
      map.foldLeft(""){ case (r,e)=>r+" "+eval(e._1)+"=\""+eval(e._2)+"\""}
    }

    def eval(expression:Any) = {
      expression match {
        case s:String=>s
        case _=> throw new UnsupportedOperationException("don't know how to eval: "+expression);
      }
    }


    private def renderText(text: String): StringBuffer =
      text.foldLeft(new StringBuffer)((buffer, c) => {renderChar(buffer, c); buffer})

    private def renderChar(buffer: StringBuffer, c: Char): Unit = {
      if ((c >= '#' && c <= '~') || c == ' ' || c == '!')
        buffer.append(c)
      else if (c == '"')
        buffer.append("\\\"")
      else {
        buffer.append("\\u")
        buffer.append(leftPad(java.lang.Integer.toHexString(c)))
      }
    }

    private def leftPad(s: String): String =
      if (s.length < 4)
        leftPad("0" + s)
      else
        s
  }


  override def generate(engine:TemplateEngine, uri:String, args:List[TemplateArg]): Code = {

    val hamlSource = engine.resourceLoader.load(uri)
    val (packageName, className) = extractPackageAndClassNames(uri)
    val statements = HamlParser.parse(hamlSource)
    val builder = new SourceBuilder()
    builder.generate(packageName, className, statements, args)

    Code(this.className(uri, args), builder.code, Set())

  }

  override def className(uri: String, args:List[TemplateArg]): String = {
    // Determine the package and class name to use for the generated class
    val (packageName, cn) = extractPackageAndClassNames(uri)

    // Build the complete class name (including the package name, if any)
    if (packageName == null || packageName.length == 0)
      cn
    else
      packageName + "." + cn
  }

  private def extractPackageAndClassNames(uri: String): (String, String) = {
    val normalizedURI = new URI(uri).normalize
    val SPLIT_ON_LAST_SLASH_REGEX = Pattern.compile("^(.*)/([^/]*)$")
    val matcher = SPLIT_ON_LAST_SLASH_REGEX.matcher(normalizedURI.toString)
    if (matcher.matches == false) throw new TemplateException("Internal error: unparseable URI [" + uri + "]")
    val packageName = matcher.group(1).replaceAll("[^A-Za-z0-9_/]", "_").replaceAll("/", ".").replaceFirst("^\\.", "")
    val cn = "$_scalate_$" + matcher.group(2).replace('.', '_')
    (packageName, cn)
  }


}
